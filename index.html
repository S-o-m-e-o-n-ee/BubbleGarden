<html>
  <head>
    <title>Bubble Garden</title>
    <style>
      html, body { 
        background-color:#000000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

    <script type="module">

      // Imports the necessary items
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; 
      import {VRButton} from 'three/addons/webxr/VRButton.js';
      import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; 

      // Declares the global variables
      var scene, camera, renderer, controls, controller, controller2, raycaster, bubbles, light;
      var baseReferenceSpace, clock, sky, ground, xdir, ydir, zdir;
      
      // Sets the values needed to animate the distortion on the bubbles
      const bubbleUniforms = {
        uTime: { value: 0 },
        uDistort: { value: 0.5 }
      };

      const bubbleMaterial = new THREE.MeshPhysicalMaterial({
        color: new THREE.Color(0.9, 0.9, 1.0),
        transmission: 1.05,
        thickness: -0.5,
        roughness: 0,
        iridescence: 1,
        iridescenceIOR: 1,
        iridescenceThicknessRange: [0, 1200],
        clearcoat: 1,
        clearcoatRoughness: 0,
        envMapIntensity: 1.5,
        transparent: true,
        opacity: 0.5
      });

      // Creates a shader to implement the distortion (heavily inspired by https://codesandbox.io/p/sandbox/focused-kirch-9dyrgh?file=%2Fsrc%2FApp.js%3A2%2C46-2%2C65)
      bubbleMaterial.onBeforeCompile = (shader) => {
        shader.uniforms.uTime = bubbleUniforms.uTime;
        shader.uniforms.uDistort = bubbleUniforms.uDistort;

        shader.vertexShader = shader.vertexShader
          .replace(
            '#include <common>',
            `
            #include <common>

            uniform float uTime;
            uniform float uDistort;

            // Simple 3D noise
            float noise(vec3 p) {
              return sin(p.x) * sin(p.y) * sin(p.z);
            }
            `
          )
          .replace(
            '#include <begin_vertex>',
            `
            vec3 transformed = position;
            float n = noise(normal + uTime * 0.5);
            transformed += normal * n * uDistort;
            `
          );
      };

      window.onload = function() {
        
        window.THREE = THREE;

        // Creates the scene
        scene = new THREE.Scene();

        // Sets up the camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 1);

        // Setsup the lights
        var ambientLight = new THREE.AmbientLight();
        scene.add(ambientLight);

        light = new THREE.DirectionalLight(0xffffff, 3.0);
        light.position.set(10, 100, 10);
        scene.add(light);

        // Creates a sky sphere for the background using sky.jpg
        var geometry = new THREE.SphereGeometry( 500, 60, 40 );
        
        var texture = new THREE.TextureLoader().load( 'sky.jpg' );
        var material = new THREE.MeshBasicMaterial( { map: texture,
                                                    side: THREE.BackSide } );

        sky = new THREE.Mesh( geometry, material );

        scene.add( sky );

        // Creates a plane for the ground
        geometry = new THREE.PlaneGeometry( 10000, 10000 );
        geometry.rotateX( 3 * Math.PI / 2 );

        material = new THREE.MeshStandardMaterial( {
          color: new THREE.Color(0.7, 0.7, 1.0), roughness: 0, metalness: 0.25
        });

        ground = new THREE.Mesh( geometry, material );
        ground.translateY(-10);

        scene.add( ground );

        // Creates the bubbles
        bubbles = new THREE.Group();

        scene.add(bubbles);

        var radius, x, y, z;
        for (var i = 0; i < 4000; i++) {
          radius = Math.random() * 5; 
          
          x = (Math.random() * 1000) - 500;
          y = (Math.random() * 30) - 5;
          z = (Math.random() * 1000) - 500;

          geometry = new THREE.SphereGeometry( radius, 32, 16 );
          material = bubbleMaterial;

          var sphere = new THREE.Mesh(geometry, material);  
          
          sphere.position.set(x, y, z);

          bubbles.add(sphere);
        };

        // Creates arrays to hold the direction that each bubble is moving in, with a default value of 1
        xdir = [];
        ydir = [];
        zdir = [];
        for (var i = 0; i < bubbles.children.length; i++){
          xdir.push(1);
          ydir.push(1);
          zdir.push(1);
        };

        // Creates the renderer, adds the canvas, and sets up for VR compatibility
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true; 
        renderer.xr.addEventListener( 'sessionstart', () => baseReferenceSpace = renderer.xr.getReferenceSpace() );
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        // Setsup camera controlls and disables them when in VR mode
        controls = new OrbitControls(camera, renderer.domElement);

        renderer.xr.addEventListener('sessionstart', () => {
          controls.enabled = false;
        });

        renderer.xr.addEventListener('sessionend', () => {
          controls.enabled = true;
        });

        // Iniciallizes the raycaster
        raycaster = new THREE.Raycaster();

        // If the mouse is over a bubble when clicked, pops the bubble
        renderer.domElement.onmousedown = function( e ){
          
          var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

          var vp_coords = new THREE.Vector2( 
                      ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                      -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

          var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

          raycaster.setFromCamera(vp_coords_near, camera);

          var intersects = raycaster.intersectObjects(bubbles.children);

          if ( intersects.length > 0 ) {
            intersects[0].object.visible = false;
            intersects[0].object.removeFromParent();
          };

        };

        // If the mouse moves over a bubble, pushes it away using the normal of the intersecting point
        renderer.domElement.onmousemove = function( e ){
          
          var pixel_coords = new THREE.Vector2( e.clientX, e.clientY );

          var vp_coords = new THREE.Vector2( 
                      ( pixel_coords.x / window.innerWidth ) * 2 - 1,  //X
                      -( pixel_coords.y / window.innerHeight ) * 2 + 1) // Y

          var vp_coords_near = new THREE.Vector3( vp_coords.x, vp_coords.y, 0);

          raycaster.setFromCamera(vp_coords_near, camera);

          var intersects = raycaster.intersectObjects(bubbles.children);

          if ( intersects.length > 0 ) {
            windPush(intersects[0]);
          };
          
        };

        // Sets up the VR controllers, and bubble popping for them
        controller = renderer.xr.getController( 0 );
        controller.addEventListener( 'selectstart', function () {
          controller.userData.isSelecting = true;

          raycaster.setFromXRController( controller );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
            intersects[0].object.visible = false;
            intersects[0].object.removeFromParent();
          }
        } );
        controller.addEventListener( 'selectend', function () {
          controller.userData.isSelecting = false;
        } );
        controller.addEventListener( 'connected', function ( event ) {

          const targetRayMode = event.data.targetRayMode;

          if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

            controller.add( buildController( event.data ) );

          }

        } );
        controller.addEventListener( 'disconnected', function () {

          controller.remove( controller.children[ 0 ] );

        } );
        scene.add(controller);

        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', function () {
          controller2.userData.isSelecting = true;

          raycaster.setFromXRController( controller2 );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
            intersects[0].object.visible = false;
            intersects[0].object.removeFromParent();
          }
        } );
        controller2.addEventListener( 'selectend', function () {
          controller2.userData.isSelecting = false;
        } );
        controller2.addEventListener( 'connected', function ( event ) {

          const targetRayMode = event.data.targetRayMode;

          if ( targetRayMode === 'tracked-pointer' || targetRayMode === 'gaze' ) {

            controller2.add( buildController( event.data ) );

          }

        } );
        controller2.addEventListener( 'disconnected', function () {

          controller2.remove( controller2.children[ 0 ] );

        } );
        scene.add(controller2);

        // For use in the animation loop
        clock = new THREE.Clock();

        // Keeps the scene looking correct even if the screen is resized
        window.addEventListener( 'resize', onWindowResize );
        
        // Calls animation loop
        renderer.setAnimationLoop(animate);
        
      };

      // Resizes the scene to match the window size
      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      // Moves the given object randomly in the given directions
      function bob(object, x_direction, y_direction, z_direction) {

        object.position.x += 0.025 * Math.random() * x_direction;
        object.position.y += 0.025 * Math.random() * y_direction;
        object.position.z += 0.025 * Math.random() * z_direction;

      }

      // Pushes an object away from a given intersection
      function windPush(from_this_intersection) {

        var normal = from_this_intersection.face.normal.clone();

        if (normal.x < 0) {
          from_this_intersection.object.position.x += 0.30;
        } else {
          from_this_intersection.object.position.x -= 0.30;
        };

        if (normal.y > 0) {
          from_this_intersection.object.position.y -= 0.30;
        } else {
          from_this_intersection.object.position.y += 0.30;
        };

        if (normal.z > 0) {
          from_this_intersection.object.position.z -= 0.30;
        } else {
          from_this_intersection.object.position.z += 0.30;
        };
      }

      // Builds a VR controller using the given data
      function buildController( data ) {

        let geometry, material;

        switch ( data.targetRayMode ) {

          case 'tracked-pointer':

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 0, 0, - 500 ], 3 ) );
            geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( [ 0.5, 0.5, 0.5, 0, 0, 0 ], 3 ) );

            material = new THREE.LineBasicMaterial( { vertexColors: true, blending: THREE.AdditiveBlending } );

            return new THREE.Line( geometry, material );

          case 'gaze':

            geometry = new THREE.RingGeometry( 0.02, 0.04, 32 ).translate( 0, 0, - 1 );
            material = new THREE.MeshBasicMaterial( { opacity: 0.5, transparent: true } );
            return new THREE.Mesh( geometry, material );

        }

      }


      // The animation loop
      function animate() {

        // Gets the elapsed time
        var time = clock.getElapsedTime();

        // Updates the time for the bubble defomaiton
        bubbleUniforms.uTime.value = time;

        // Updates the lights color, cylcing through all the hues
        if (light) {
          light.color.setHSL(((time/100) % 1), 0.7, 0.9);
        }

        // If the controllers exist (we are in VR mode), then pushes bubbles away when they intersect
        if (controller) {
          raycaster.setFromXRController( controller );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
              windPush(intersects[0]);
          };
        } 
        if (controller2) {
          raycaster.setFromXRController( controller2 );

          const intersects = raycaster.intersectObjects( bubbles.children, false );

          if ( intersects.length > 0 ) {
              windPush(intersects[0]);
          };
        }

        // Runs the random motion for the bubbles
        for (var i = 0; i < bubbles.children.length; i++){
          if (Math.random() < 0.001) {
            xdir[i] = -xdir[i];
          };
          if (Math.random() < 0.001) {
            ydir[i] = -ydir[i];
          };
          if (Math.random() < 0.001) {
            zdir[i] = -zdir[i];
          };

          if (Math.abs(bubbles.children[i].position.x) > 500) {
            xdir[i] = bubbles.children[i].position.x > 0 ? -1 : 1;
          };
          if (bubbles.children[i].position.y < -5) {
            ydir[i] = 1;
          };
          if (Math.abs(bubbles.children[i].position.z) > 500) {
            zdir[i] = bubbles.children[i].position.z > 0 ? -1 : 1;
          };

          if (Math.random() > 0.7){
            bob(bubbles.children[i], xdir[i], ydir[i], zdir[i]);
          };
        };

        // Updates the renderer and controls
        controls.update();
        renderer.render(scene, camera);
      };
    </script>
  </head>
  <body></body>
</html>
